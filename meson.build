

# meson setup build
# ninja -C build -j 12
project( 'sc',
  'c',
  version : configure_file(input: 'VERSION', output: 'VERSION', copy: true),
  license : 'GPL',
  meson_version: '>= 0.61.0',
  default_options : [
    'c_std=gnu11' ] )

cc = meson.get_compiler('c')

compiler_options = [
  '-Wno-unknown-warning-option',
  '-Wno-unused-variable',
  '-Wno-unused-parameter',
  '-Wno-unused-but-set-variable',
  '-Wno-unused-function',
  '-Wfatal-errors',
  '-Wnull-dereference',
  '-Warray-bounds=2',
  '-Werror-implicit-function-declaration',
  '-Werror=return-type',
  '-Werror=discarded-qualifiers' ]

cc_options = []

# enable POSIX features
c_args = [
  '-D_POSIX_C_SOURCE=200809L' ]

link_args = []


pkgconfig = import('pkgconfig')

# Used to run some of the general build scripts
py_mod = import('python')
py3 = py_mod.find_installation('python3', required: true)

py3_dep = py3.dependency( required: true )

message('Python: ' + py3.language_version())

if not py3.language_version().version_compare('>= 3.6')
  error('Python 3.6 or newer is required')
endif

# use the console command:
#  date "+%s" to obtain the build number
build_number = run_command(py3,
  [ '-c',
    'import time; print(str(int(time.time())))' ],
  check: true ).stdout().strip()

check_functions = {
  'adler32_combine' : 'SC_HAVE_ZLIB',
  'aligned_alloc' : 'SC_HAVE_ALIGNED_ALLOC',
  'posix_memalign' : 'SC_HAVE_POSIX_MEMALIGN',
  'backtrace' : 'SC_HAVE_BACKTRACE',
  'backtrace_symbols' : 'SC_HAVE_BACKTRACE_SYMBOLS',
  'fsync' : 'SC_HAVE_FSYNC',
  'qsort_r' : 'SC_HAVE_QSORT_R',
  'strtol' : 'SC_HAVE_STRTOL' }

# TODO: Why do these all get checked if the code can't compile without them?
check_headers = {
  'execinfo.h' : 'SC_HAVE_EXECINFO_H',
  'fcntl.h' : 'SC_HAVE_FCNTL_H',
  'signal.h' : 'SC_HAVE_SIGNAL_H',
  'time.h' : 'SC_HAVE_TIME_H',
  'unistd.h' : 'SC_HAVE_UNISTD_H',
  'sys/select.h' : 'SC_HAVE_SYS_SELECT_H',
  'sys/stat.h' : 'SC_HAVE_SYS_STAT_H',
  'sys/time.h' : 'SC_HAVE_SYS_TIME_H',
  'sys/types.h' : 'SC_HAVE_SYS_TYPES_H',
  'sys/ioctl.h' : 'SC_HAVE_SYS_IOCTL_H',
  'linux/videodev2.h' : 'SC_HAVE_LINUX_VIDEODEV2_H' }

foreach func, macro : check_functions
  if cc.has_function(func)
    c_args += [ '-D@0@=1'.format(macro) ]
  endif
endforeach

foreach header, macro : check_headers
  if cc.has_header(header)
    c_args += [ '-D@0@=1'.format(macro) ]
  endif
endforeach

# use aligned malloc (optionally use --enable-memalign=<bytes>)
# SC_ENABLE_MEMALIGN 1


# Development with V4L2 devices works ???
# SC_ENABLE_V4L2


# SC_WITH_BLAS
# SC_WITH_LAPACK

# SC_ENABLE_DEBUG
# SC_ENABLE_MPI
# SC_ENABLE_MPIIO

# Define to 1 if we can use MPI_COMM_TYPE_SHARED
# #define SC_ENABLE_MPICOMMSHARED 1

# 1 if we are using MPI I/O
# #define SC_ENABLE_MPIIO 1

# 1 if we are using MPI_Init_thread
# #define SC_ENABLE_MPITHREAD 1

# 1 if we can use MPI_Win_allocate_shared
# #define SC_ENABLE_MPIWINSHARED 1

# --enable-pthread without arguments does not
#    specify any CFLAGS; to supply CFLAGS use --enable-pthread=<PTHREAD_CFLAGS>.
#    We check first for linking without any libraries and then with -lpthread;
#    to avoid the latter, specify LIBS=<PTHREAD_LIBS> on configure line
# #define SC_ENABLE_PTHREAD

# // TODO: not generated by auto-tools, but used in code???
# // SC_PAPI
# // SC_PROVIDE_GETOPT
# // SC_PROVIDE_OBSTACK

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# External library dependencies
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# NOTE: the math library is made optional for systems without an independent math library
m_deps = [
  cc.find_library('m', required : false ) ]


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Check for enabling MPI
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# NOTE: there is currently a bug in mesonbuild detection of MPI as a named
# dependency. This simply checks that the mpi library can be found.
# TODO: revert when meson merges the open issue for MPI dependency checks


# NOTE: this is manually checking for the mpicc and mpicxx wrappers, even if
# they were not manually specified through the command line.
# https://github.com/mesonbuild/meson/pull/7373

mpi_deps = [
  cc.find_library('mpi',
    required : true ) ]

mpi_h = cc.has_header('mpi.h',
  required : true )

mpi_cc_code = '''
#include <mpi.h>

int main(void) {
  MPI_Init( 0, 0 );
  MPI_Comm comm = MPI_COMM_WORLD;
  int size;
  MPI_Comm_size( comm, &size );
  MPI_Finalize();
  return 0;
}
'''

mpi_run = cc.run(
  mpi_cc_code,
  dependencies: mpi_deps,
  name : 'MPI program' )

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# check/prepare for building the python extension
# https://mesonbuild.com/Python-module.html
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# ensure mpi4py python package is available
py3_mpi = py_mod.find_installation(
  'python3',
  modules : ['mpi4py'],
  required: true )

py3_deps = [py3_dep,] + mpi_deps + m_deps

cython = find_program(
  'cython',
  required : true )

# disable NumPy deprecated API
numpy_nodepr_api = '-DNPY_NO_DEPRECATED_API=NPY_1_9_API_VERSION'

c_args += [numpy_nodepr_api]

# Python include directory
incdir_py3 = run_command(py3,
  [ '-c',
    'from sysconfig import get_paths; print(get_paths()["include"])' ],
  check: true ).stdout().strip()

message('Python includes: ' + incdir_py3)
py3_inc = include_directories(incdir_py3)

# NumPy include directory
incdir_numpy = run_command(py3,
  [ '-c',
    'import numpy; print(numpy.get_include())' ],
  check: true ).stdout().strip()

message('NumPy includes: ' + incdir_numpy)
np_inc = include_directories(incdir_numpy)


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# set desired compiler options, if available
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# foreach w : compiler_options
#   if cc.has_argument(w)
#     add_global_arguments(w, language : 'c')
#   endif
# endforeach

# foreach w : cc_options
#   if cc.has_argument(w)
#     add_global_arguments(w, language : 'c')
#   endif
# endforeach

sc_inc = include_directories('src')

iniparser_inc = include_directories('iniparser')
libb64_inc = include_directories('libb64')

sc_inc = [sc_inc, iniparser_inc, libb64_inc]

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# configure files
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

build_number_file = configure_file(
  input: 'BUILDNUMBER.in',
  output: 'BUILDNUMBER',
  configuration : {
    'buildnumber' : build_number })


subdir('iniparser')
subdir('libb64')
subdir('src')

sc_shared_dep = declare_dependency(
  include_directories : sc_inc,
  link_with : sc_shared_lib )
  